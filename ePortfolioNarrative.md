CS-499-Capstone

Thermostat Enhancement (Python, GPIO, State Machine) (Software Design and Engineering Checkpoint)
This artifact is a Python-based thermostat system initially developed as part of my coursework. The original version was created during CS-350: Emerging Systems Architecture & Technology and ran on a Raspberry Pi using I²C temperature sensors, a character LCD display, and GPIO-controlled heating/cooling indicators. The project used a state machine to cycle between “off,” “heat,” and “cool” modes. The enhanced version of the artifact was completed during my CS-499 capstone project.
I selected this artifact for my ePortfolio because it demonstrates my ability to apply embedded system principles, control logic, and real-time hardware interactions in a meaningful way. The enhancement added a real-world logging component by integrating a SQLite database for recording temperature readings and state transitions. This change introduced greater complexity and brought the project closer to a fully functional IoT-style solution. It showcases my skills in sensor integration, Python threading, serial communication, and software design patterns like finite state machines.
The enhancement process involved analyzing weaknesses in the original design — specifically the lack of persistent data storage and limited debugging information. I added a database schema, wrote logic for periodic temperature logging, and made sure that the device could track long-term HVAC behavior. I also made the display loop cleaner and added safeguards against sensor failures. The most challenging aspect was making sure the database writes did not block the real-time nature of the display and LED control. I solved this by carefully threading the display and serial update loop. I incorporated debugging feedback from my instructor, which led to improved error handling for I²C failures. Through this enhancement, I reinforced my understanding of concurrent programming, real-time feedback loops, and the importance of fail-safe hardware-software interactions.This enhancement helped me fully meet Course Outcome 3 (design and evaluate computing solutions using algorithmic principles and CS practices) and Outcome 4 (use innovative techniques and tools in computing). I also partially met Outcome 5 by considering software security and failure modes in a hardware-connected environment. It was a strong capstone to my embedded systems learning path.

ABCU Banking System (Java GUI Application)(Databases Checkpoint)
This artifact is a Java-based desktop banking application created during CS-300: Software Development Lifecycle. It simulates a simple banking system for ABCU Credit Union with functionality for users to log in, view balances, make deposits or withdrawals, and manage customer records. The original version included basic account operations through a GUI using Java Swing and local data handling. The enhanced version, completed later in my program, expanded features such as transaction validation, clearer user feedback, and modular code design.
I included this artifact because it demonstrates my grasp of core software development principles such as modularity, user interface design, and structured programming. The ABCU project reflects my ability to build a full-stack application (frontend and logic layer) from scratch using Java, a foundational programming language. In the enhancement, I refactored many parts of the code to follow separation of concerns, improved the user experience with clearer GUI elements, and cleaned up error-prone logic. These enhancements demonstrate my growth in software architecture and my ability to revisit and improve a project based on feedback and best practices.
During the enhancement phase, I focused on improving the maintainability and usability of the code. I broke down long methods into smaller, more testable units and reorganized the project files to better reflect the Model-View-Controller (MVC) pattern. One of the key lessons was understanding the importance of intuitive user flow and how confusing UI behaviors can disrupt functionality. I also gained deeper experience working with Java Swing components and event-driven programming. One of the biggest challenges was improving the input validation logic while preserving the program’s structure. I used feedback from code reviews to refine areas where redundant code and poor exception handling had previously caused instability.This enhancement helped me meet Course Outcome 2 (professional-quality written and visual communications) through improved GUI design, and Course Outcome 3 (design and evaluate solutions using CS practices). I also partially achieved Outcome 4 (innovative techniques) by applying the MVC pattern and Outcome 1 (collaborative environments) through peer reviews that shaped my updates.

Full Stack Travel Planner Web App (MEAN Stack)(Algorithms and Data Structures Checkpoint)
This artifact is a full stack travel planning web application developed during CS-465: Full Stack Development. The application allows users to browse, search, and manage trip destinations through a dynamic interface. The project was built using the MEAN stack — MongoDB for the database, Express.js and Node.js for the backend API, and Angular for the frontend interface. The enhanced version added search filters, routing improvements, and backend API refactoring for better maintainability.
I selected this artifact because it demonstrates my ability to build modern, data-driven web applications using an end-to-end JavaScript-based technology stack. The project showcases key skills including RESTful API development, database integration, component-based UI design, and asynchronous data handling. The enhancement reflects significant growth in my development workflow: I separated concerns between the API and frontend, made reusable Angular components, and improved the overall scalability of the app. These improvements directly show my competency in building production-quality web solutions.
Reflection on the Enhancement Process
While enhancing the artifact, I focused heavily on modularizing the API and improving the frontend user experience. I implemented Angular routing to allow deep linking and cleaner navigation between trip views, and I added client-side input validation to catch user errors before reaching the backend. On the backend, I reorganized Express routes and added middleware for more secure and readable code. One challenge was keeping frontend data in sync with the backend after user interactions like filtering or editing trips. I used Angular services and reactive forms to resolve those issues. Through the enhancement, I learned the importance of clear separation between logic and presentation, and how to design APIs that are flexible and consistent.
This enhancement fully meets Course Outcome 3 (evaluate computing solutions using appropriate CS practices) and Course Outcome 4 (use innovative tools and techniques in computing). It also contributes to Outcome 2 (professional-quality visual communications) through its polished frontend and clean user flow. I gained practical experience in all layers of full stack development and created an artifact that is visually appealing, logically sound, and functionally complete.
